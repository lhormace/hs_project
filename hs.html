<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>hs_project</title>
<script type="text/javascript">
    // TODO:全体的にコメントが足りてない
    // TODO:画像が全て書き直しが必要。無料のツールで作成したために、コピー防止のロゴが入っている。
    const NUM = 10;
    var unitType = new Array(10);
    var unitX = new Array(10);
    var unitY = new Array(10);
    var ctx;
    var sideCtx;
    const TOPX_SIZE = 10;
    const TOPY_SIZE = 10;
    const MERGIN = 10;
    var pressedKey = 0;
    const CURSOR_START_X = 0;
    const CURSOR_START_Y = 0;
    var nowCursorX = 0;
    var nowCursorY = 0;
    var messageWindowCtx;
    var messageWindow = new Array(5);
    var gameLevel = 0;
    var MAX_EIRIAN_NUM = 10;
    var eirianX = new Array(100);
    var eirianY = new Array(100);
    var eirianType = new Array(100);
    var eirianEnabledFlg = new Array(100);
    var lastCreateEirian = 0;
    
    // カーソルのステータス
    // 0 --> 通常の状態
    // 1 --> 選択した状態
    // 2 --> ユニットをドラッグした状態
    // 3 --> ユニットを離した状態（このあとすぐに、ステータスは０になる）
    var cursorStatus = 0;
    
    // カーソルで選択状態としたユニットの番号
    var selectedUnitNo = 0;
    
    // カーソル選択状態で過去に塗りつぶしたカーソル位置の座標
    var oldCursorX = 0;
    var oldCursorY = 0;
    
    // カーソルを選択した際に始点となり、解放されていない位置
    var selectedCursorX = 0;
    var selectedCursorY = 0;

    function newMessage(message) {
        messageWindowCtx.beginPath();
        messageWindowCtx.fillStyle="rgb(255,255,255)";
        messageWindowCtx.fillRect(0,0,500,120);
        messageWindowCtx.closePath();
        messageWindowCtx.stroke();

        //テキスト描画のスタイルを指定する
        messageWindowCtx.fillStyle = "black";
        messageWindowCtx.font = "10px 'ＭＳ ゴシック'";
        messageWindowCtx.textAlign = "left";
        messageWindowCtx.textBaseline = "top";

        for (var i=0;i<5;i++) {
            messageWindow[i] = messageWindow[i+1];
        }
        messageWindow[4] = message;
        for (i=0;i<5;i++) {
            messageWindowCtx.fillText(messageWindow[i], 2, i*20+2, 490);
        }
    }

    /**
     * サイドスクリーンをクリア
     *
     */
    function clearCanvasDraw() {
    	var img = new Image();
    	img.src = "./pattern_128.gif";
    	/* 画像を描画 */
    	sideCtx.drawImage(img, 0, 0);
    	sideCtx.drawImage(img, 49, 0);
    	sideCtx.drawImage(img, 98, 0);
    	sideCtx.drawImage(img, 147, 0);
    	sideCtx.drawImage(img, 196, 0);
    	sideCtx.drawImage(img, 0, 98);
    	sideCtx.drawImage(img, 49, 98);
    	sideCtx.drawImage(img, 98, 98);
    	sideCtx.drawImage(img, 147, 98);
    	sideCtx.drawImage(img, 196, 98);
    	sideCtx.drawImage(img, 0, 196);
    	sideCtx.drawImage(img, 49, 196);
    	sideCtx.drawImage(img, 98, 196);
    	sideCtx.drawImage(img, 147, 196);
    	sideCtx.drawImage(img, 196, 196);
    	sideCtx.drawImage(img, 0, 294);
    	sideCtx.drawImage(img, 49, 294);
    	sideCtx.drawImage(img, 98, 294);
    	sideCtx.drawImage(img, 147, 294);
    	sideCtx.drawImage(img, 196, 294);
    }
    
    /**
     * サイドスクリーンに選択されたユニットの情報を描画
     * param: unitNo 選択されたユニットの番号
     */
    function sideCanvasDraw(unitNo) {
/*    	sideCtx.beginPath();
    	sideCtx.fillStyle="rgb(0,0,0)";
    	sideCtx.fillRect(0,0,150,500);
    	sideCtx.closePath();
    	sideCtx.stroke();*/
    	var img = new Image();
    	img.src = "./pattern_128.gif";
    	
    	/* 画像を描画 */
    	sideCtx.drawImage(img, 0, 0);
        sideCtx.beginPath();
        sideCtx.fillStyle="rgb(255,255,255)";
        sideCtx.fillRect(0,0,500,300);
        sideCtx.closePath();
        sideCtx.stroke();

        //テキスト描画のスタイルを指定する
        sideCtx.fillStyle = "black";
        sideCtx.font = "10px 'ＭＳ ゴシック'";
        sideCtx.textAlign = "left";
        sideCtx.textBaseline = "top";

        sideCtx.fillText("[" + "*****" + "]",2,10);
        sideCtx.fillText("X:" + unitX[unitNo],2, 20);
        sideCtx.fillText("Y:" + unitY[unitNo],2, 30);
        sideCtx.fillText("NM:",2, 40);
        sideCtx.fillText("KRM:",2, 50);
        sideCtx.fillText("HP:",2, 60);
        sideCtx.fillText("MP:",2, 70);
        sideCtx.fillText("STR:",2, 80);
        sideCtx.fillText("INT:",2, 90);
        sideCtx.fillText("WDM:",2, 100);
        sideCtx.fillText("DEX",2, 110);
        sideCtx.fillText("CON:",2, 120);
        sideCtx.fillText("CRM:",2, 130);
        sideCtx.fillText("ROL:",2, 140);
        sideCtx.fillText("KRM:",2, 150);
    }

    /* デフォルトパラメータの初期化（処理開始の時に必ず１回だけ実行する） */
    function initializeDefaultParameter() {
        // エイリアンを初期化
        for(var i=0; i<MAX_EIRIAN_NUM; i++) {
            eirianX[i] = 0;
            eirianY[i] = 0;
            eirianType[i] = 1;
            eirianEnabledFlg[i] = 0;
        }
        // メッセージウィンドウを初期化
        messageWindow[0] = " ";
        messageWindow[1] = " ";
        messageWindow[2] = " ";
        messageWindow[3] = " ";
        messageWindow[4] = " ";

    }

    function init(){
        // デフォルトパラメータの初期化処理
        initializeDefaultParameter();
        
        // コマンドラインによる入力
        gameLevel = prompt("GAME LEVEL を入力してください。(1 - 10)", gameLevel);

        // 入力値のチェック
        while(true) {
            if (gameLevel >= 1 && gameLevel <= 10) {
                break;
            }
            gameLevel = prompt("入力に誤りがあります。GAME LEVEL を再度入力してください。(1 - 10)", gameLevel);
        }

        // ゲーム用のメインキャンバスを取得
        var canvas = document.getElementById('main_canvas');
        if (canvas.getContext){
            ctx = canvas.getContext('2d');
            ctx.save();
        }

        // ゲーム用のサイドキャンバスを取得
        var side_canvas = document.getElementById('side_canvas');
        if (side_canvas.getContext){
            sideCtx = side_canvas.getContext('2d');
            sideCtx.save();
        }

        // メッセージ出力用ウィンドウを取得
        var message_window_canvas = document.getElementById('message_window');
        if (message_window_canvas.getContext){
            messageWindowCtx = message_window_canvas.getContext('2d');
        }
        // TODO:メッセージの表示が安っぽい。もう少しアニーメーション的にスクロールすべきだ
        // TODO:メッセージの下側の空白が不要
        
        newMessage("ゲームのレベルは[" + gameLevel + "]が設定されました。");
        newMessage("ゲームを開始します。");
        
        // MAINのCANVASを設定
        ctx.beginPath();
        ctx.fillStyle="rgb(255,255,255)";
        ctx.fillRect(0,0,500,500);
        ctx.closePath();
        ctx.stroke();

        if (canvas.getContext) {
            var context = canvas.getContext('2d');
        }

        if (canvas.getContext){
            var counter = 0;
            var innerWhileCond = true;
            var outerWhileCond = true;
            
            // 自軍のユニットを配置する
		    while(outerWhileCond){
                if(counter > 10) {
                    outerWhileCond = false;
                } else {
                    innerWhileCond = true;
                }
                while(innerWhileCond) {
                    unitX[counter] = Math.floor((Math.random() * 10.0)) + 1;
                    unitY[counter] = Math.floor((Math.random() * 10.0)) + 1;
                    unitType[counter] = Math.floor((Math.random() * 12.0)) + 1;
                    if (counter==0) {
                        console.log(counter + " unitX[" + unitX[counter]+ "] unitY[" + unitY[counter] + "] unitType[" + unitType[counter] + "]");
                        innerWhileCond = false;
                    }
                    for(var j = 0; j <= counter; j++){
                        if(unitX[counter] == unitX[j] && unitY[counter] == unitY[j]) {
                            ;
                        } else {
                            console.log(counter + " unitX[" + unitX[counter]+ "] unitY[" + unitY[counter] + "] unitType[" + unitType[counter] + "]");
                            innerWhileCond = false;
                        }
                    }
                 }
                 counter++;
		   	}

		    // ゲーム盤の仕切り線（マス目）を作成
	        for(var j = 0; j < TOPX_SIZE; j++){
	            for(var k = 0;k < TOPY_SIZE; k++){
	                drawLeftUp(j, k, 64, 64, 64, MERGIN);
	                drawRightUp(j, k, 64, 64, 64, MERGIN);
	                drawLeftDown(j, k, 64, 64, 64, MERGIN);
	                drawRightDown(j, k, 64, 64, 64, MERGIN);
	            }
	        }
		    
	        // ゲーム盤の初期化（全て森のマスにする）
	        drawBackGroundImage();

            /* マウスハンドラのイベント取得を開始 */
            document.onmousemove = getMouseXY;
            document.onmousedown = getMouseDown;            

            // ------------------------------------------------------------
            // イベントのリッスンを開始する
            // ------------------------------------------------------------
            // イベントリスナーに対応している
            if (document.addEventListener) {

	        // キーボードを押したときに実行されるイベント
	        document.addEventListener("keydown" , KeyDownFunc);

                // アタッチイベントに対応している
            } else if(document.attachEvent) {

	        // キーボードを押したときに実行されるイベント
	        document.attachEvent("onkeydown" , KeyDownFunc);

            }

　　　　/* 画面表示のシーケンスは200ミリsecごと */
       // カーソルの移動と、何らかのアニメーションはここで制御
　　　　setInterval(draw, 200);
       //TODO:カーソルが点滅すべきだ

       // hiddenでtextボックスを作り第一引数に渡す設計で表示できるはず
       // http://www.html5.jp/canvas/ref/method/fillText.html
       // hidden textボックスは配列で５行持ち自動でスクロールさせる関数と
       // 一番下の行に文字列を入力する関数を用意する

       // todo: DIVタグを打てば<form></form>に定義された項目も取得できる可能性がある
       // todo: 枠を表示するプログラムは、外だしにしてjsファイルとしたい
       

    }
	}

    /* 左上の枠 */
    function drawLeftUp(j, k, r, g, b, mergin){
                    ctx.strokeStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.beginPath();
                    ctx.moveTo(j*50, k*50);
                    ctx.lineTo(j*50+25, k*50);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(j*50, k*50);
                    ctx.lineTo(j*50, k*50+25);
                    ctx.closePath();
                    ctx.stroke();
    }

    /* 左下の枠 */
    function drawLeftDown(j, k, r, g, b){
                    ctx.strokeStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.beginPath();
                    ctx.moveTo(j*50, k*50+50);
                    ctx.lineTo(j*50, k*50+25);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(j*50, k*50+50);
                    ctx.lineTo(j*50+25, k*50+50);
                    ctx.closePath();
                    ctx.stroke();
    }

    /* 右上の枠 */
    function drawRightUp(j, k, r, g, b){
                    ctx.strokeStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.beginPath();
                    ctx.moveTo(j*50+50, k*50);
                    ctx.lineTo(j*50+25, k*50);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(j*50+50, k*50);
                    ctx.lineTo(j*50+50, k*50+25);
                    ctx.closePath();
                    ctx.stroke();
    }

    /* 右下の枠 */
    function drawRightDown(j, k, r, g, b){
                    ctx.strokeStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
                    ctx.beginPath();
                    ctx.moveTo(j*50+50, k*50+50);
                    ctx.lineTo(j*50+25, k*50+50);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(j*50+50, k*50+50);
                    ctx.lineTo(j*50+50, k*50+25);
                    ctx.closePath();
                    ctx.stroke();
    }

    function draw(){
    	
    	// 自軍のユニットをすべて書き直す
        clearUnitsAll();
        setUnitsAll();
        
        // 新しいユニットを作成する
        createNewEirian();
        
        // エイリアンのユニットをすべて書き直す
        clearEirian();
        setEirian();
        
        // マウスが選択状態である場合選択した箇所を黄色に塗りつぶす(消された場合の為に書き直す)
        if (cursorStatus == 1) {
	        ctx.beginPath();
	        ctx.fillStyle="rgb(255,250,15)";
	        ctx.fillRect((selectedCursorX-1)*50+2,(selectedCursorY-1)*50+2,47,47);
	        ctx.closePath();
	        ctx.stroke();
        }
        
/*	ctx.globalCompositeOperation = "source-over";
	ctx.fillStyle = "rgba(8,8,12,.1)";
	ctx.fillRect(0, 0, WIDTH, HEIGHT);
	ctx.globalCompositeOperation = "lighter";

	for(var i = 0; i < NUM; i++){
	    //位置を更新
	    locX[i] += speedX[i];
	    locY[i] += speedY[i];
	    
	    if(locX[i] < 0 || locX[i] > WIDTH){
		speedX[i] *= -1.0;
	    }

	    if(locY[i] < 0 || locY[i] > HEIGHT){
		speedY[i] *= -1.0;
	    }
	    
	    //更新した座標で円を描く
	    ctx.beginPath();
	    ctx.fillStyle = 'rgb(' + r[i] + ',' + g[i] + ',' + b[i] + ')';
            ctx.arc(locX[i], locY[i], radius[i], 0, Math.PI*2.0, true);
            ctx.fill();
	}
*/
    }

    function getMouseXY(event){
        var targetCursorX = Math.floor((event.clientX - 8) / 50) + 1;
        var targetCursorY = Math.floor((event.clientY - 8) / 50) + 1;
        
        // カーソルを押下した状態かつユニットを選択した状態である
        if (cursorStatus == 1) {
        	// 前回反転した色を元に戻す
            ctx.beginPath();
            ctx.fillStyle="rgb(255,255,255)";
            ctx.fillRect((oldCursorX-1)*50+2,(oldCursorY-1)*50+2,47,47);
            ctx.closePath();
            ctx.stroke();
        	
        	// 画面上を移動したマウスポインタに該当するカーソル位置の色を反転する。
            ctx.beginPath();
            ctx.fillStyle="rgb(128,128,255)";
            ctx.fillRect((targetCursorX-1)*50+2,(targetCursorY-1)*50+2,47,47);
            ctx.closePath();
            ctx.stroke();
            
            // 新しく移動した先のカーソルは色をクリアする為に座標を保存する
            oldCursorX = targetCursorX;
            oldCursorY = targetCursorY;
        }
        
//        alert("targetCursorX[" + targetCursorX + "(" + event.clientX + ")] targetCursorY[" + targetCursorY + "(" + event.clientY + ")]");
    	/*alert("screenX[" + event.screenX + "] screenY[" + event.screenY + "] pageX[" + event.pageX + "] pageY[" + event.pageY + "] clientX[" + event.clientX + "] clientY[" + event.clientY + "] offsetX[" + event.offsetX + "] offsetY[" + event.offsetY + "]");*/
/*        console.log("screenX[" + event.screenX + "] screenY[" + event.screenY + "] pageX[" + event.pageX + "] pageY[" + event.pageY + "] clientX[" + event.clientX + "] clientY[" + event.clientY + "] offsetX[" + event.offsetX + "] offsetY[" + event.offsetY + "]");
*/
    }

    function getMouseDown(event){
        var check_eirian_hit = 0;
        var unitFoundFlg = 0;
        var eirianFoundFlg = 0;

        // 移動前のカーソルを消す
        ctx.beginPath();
        ctx.fillStyle="rgb(255,255,255)";
        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
        ctx.closePath();
        ctx.stroke();

        var targetCursorX = Math.floor((event.clientX - 8) / 50) + 1;
        var targetCursorY = Math.floor((event.clientY - 8) / 50) + 1;

        console.log("MOUSE DOWN PRESSED targetCursorX[" + targetCursorX + "] targetCursorY[" + targetCursorY + "] screenX[" + event.screenX + "] screenY[" + event.screenY + "] pageX[" + event.pageX + "] pageY[" + event.pageY + "] clientX[" + event.clientX + "] clientY[" + event.clientY + "] offsetX[" + event.offsetX + "] offsetY[" + event.offsetY + "]");

        nowCursorX = targetCursorX;
        nowCursorY = targetCursorY;

        // カーソルの選択状態を判定する
        if (cursorStatus == 0) {
        	// カーソルが通常の状態の場合は、押下した位置にユニットがあるか否かを判定する。
        	for (var i=0; i<NUM; i++) {
        		if ((targetCursorX == unitX[i]) && (targetCursorY == unitY[i])) {
        			// 一致するユニットがあった場合
        			// 画面右上のユニット情報領域に、ユニットのステータスを表示する
        			sideCanvasDraw(i);
        			// ユニットは選択状態の画像に変更する
        			
        			// カーソルも選択状態の色（青色）に変更する
        			
        			// ステータスは０(通常)-->1(選択状態)へ変更する
        			cursorStatus = 1;
        			
        			// 選択状態のユニットの番号を保持する。
        			selectedUnitNo = i;
        			
        			// 選択した位置を保持する。
        			selectedCursorX = targetCursorX;
        			selectedCursorY = targetCursorY;
        		}
        	}

        	// 選択状態では無い場合はあたり判定を行い、射程距離以内であれば、エイリアンに傷を負わせる
            for (var i=0; i<NUM; i++){
                if(targetCursorX - 1 == unitX[i]){
                    if(targetCursorY - 1 == unitY[i]){
                        // 左上のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX - 1) * 50 + 25,targetCursorY * 50 + 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                    if(targetCursorY == unitY[i]){
                        // 左のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX - 1) * 50 + 25,targetCursorY * 50 + 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                    if(targetCursorY + 1 == unitY[i]){
                        // 左下のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX - 1) * 50 + 25,targetCursorY * 50 + 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                }
                if(targetCursorX == unitX[i]){
                    if(targetCursorY - 1 == unitY[i]){
                        // 上のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect(targetCursorX * 50,targetCursorY * 50 - 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                    if(targetCursorY + 1 == unitY[i]){
                        // 下のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect(targetCursorX * 50,targetCursorY * 50 + 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                }
                if(targetCursorX + 1 == unitX[i]){
                    if(targetCursorY - 1 == unitY[i]){
                        // 右上のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX + 1) * 50 - 25,targetCursorY * 50 - 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                    if(targetCursorY == unitY[i]){
                        // 右のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX + 1) * 50 - 25,targetCursorY * 50 - 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                    if(targetCursorY + 1 == unitY[i]){
                        // 右下のユニット
    /*                    ctx.beginPath();
                        ctx.fillStyle="rgb(255,32,32)";
                        ctx.fillRect((targetCursorX + 1) * 50 - 25,targetCursorY * 50 - 25,47,47);
                        ctx.closePath();
                        ctx.stroke();*/
                        check_eirian_hit = 1;
                    }
                }
            }
            if(check_eirian_hit == 1) {
                var ret = destroyEirian();
                if (ret == 1) {
                    // 破壊した場合は、カーソルを赤色に描画
        	        ctx.beginPath();
        	        ctx.fillStyle="rgb(255,32,32)";
        	        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
        	        ctx.closePath();
        	        ctx.stroke();
                } else {
                    // 攻撃範囲に的がいなかった場合は通常のカーソルを描画
                    if (cursorStatus == 0) {
                    	// 自軍ユニット未選択状態の場合は、カーソルの色は「黒」でぬりつぶす。
        		        ctx.beginPath();
        		        ctx.fillStyle="rgb(32,32,32)";
        		        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
        		        ctx.closePath();
        		        ctx.stroke();
                    } else if (cursorStatus == 1) {
                    	// 自軍ユニット未選択状態の場合は、カーソルの色は「青」でぬりつぶす。
        		        ctx.beginPath();
        		        ctx.fillStyle="rgb(32,32,255)";
        		        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
        		        ctx.closePath();
        		        ctx.stroke();
                    }
                }
            } else {
                // UNITの攻撃範囲外は通常のカーソルを描画
                if (cursorStatus == 0) {
                	// 自軍ユニット未選択状態の場合は、カーソルの色は「黒」でぬりつぶす。
    		        ctx.beginPath();
    		        ctx.fillStyle="rgb(32,32,32)";
    		        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
    		        ctx.closePath();
    		        ctx.stroke();
                } else if (cursorStatus == 1) {
                	// 自軍ユニット未選択状態の場合は、カーソルの色は「青」でぬりつぶす。
    		        ctx.beginPath();
    		        ctx.fillStyle="rgb(32,32,255)";
    		        ctx.fillRect((nowCursorX-1)*50+2,(nowCursorY-1)*50+2,47,47);
    		        ctx.closePath();
    		        ctx.stroke();
                }
            }
        
        } else if (cursorStatus == 1) {
        	// カーソルが選択状態である場合
        	
        	// 1. 新たにクリックした場所に、敵が存在している場合、移動できない
        	for (var i=0; i<MAX_EIRIAN_NUM; i++) {
				eirianFoundFlg = 0;        		
        		if ((targetCursorX == eirianX[i]) && (targetCursorY == eirianY[i])) {
        			eirianFoundFlg = 1;
        			break;
        		}
        	}
        	// 2. 新たにクリックした場所に、味方のユニットが存在している？
        	if (eirianFoundFlg == 0) {
	        	for (var i=0; i<NUM; i++) {
					eirianFoundFlg = 0;        		
	        		if ((targetCursorX == unitX[i]) && (targetCursorY == unitY[i])) {
	        			unitFoundFlg = 1;
	        			break;
	        		}
	        	}
        	}
        	
        	// 3. 移動先が既にユニットで埋まっていなければ、カーソル位置へ選択済みのユニットを動かす
        	if ((eirianFoundFlg == 0) && (unitFoundFlg == 0)) {
        		unitX[selectedUnitNo] = targetCursorX;
        		unitY[selectedUnitNo] = targetCursorY;
        	}
        	
        	// TODO:未着手少し後回し(難易度高い)判定方法：ユニットの移動距離はクリアしているか？（ユニットの移動距離の範囲外であれば、エラーを出力する）
        	
        	// 4. ユニットの画像を変更する。（任意の場所に動く）
        	
        	// 5. カーソルを元に戻す
        	cursorStatus = 0;
        	
        	// 6. サイドメニューのステータスは消される
        	clearCanvasDraw();

        	// 7. カーソルは選択状態ではなくなったので元の色に戻す
 	        ctx.beginPath();
   	        ctx.fillStyle="rgb(255,255,255)";
   	        ctx.fillRect((selectedCursorX-1)*50+2,(selectedCursorY-1)*50+2,47,47);
   	        ctx.closePath();
   	        ctx.stroke();
        }
        
        /* 味方ユニットの選択状態 */
        // クリック時
        // 　選択状態がON
        // 　　次のクリックで選択されていたユニットが移動する
        // 　選択状態がOFF
        // 　　ユニットを選択状態にする（青色）
        // 連続で同じユニットをクリックした場合は、カーソルは元に戻す。
        // TODO:選択中（青色）のユニットの画像が必要
        // TODO:ユニットが移動する時のアニメーションを検討が必要
    }

function destroyEirian() {
    console.log("destoryEirian() start.");
	for(var i=0; i<MAX_EIRIAN_NUM; i++) {
        if((eirianX[i] == nowCursorX) && (eirianY[i] == nowCursorY)) {
            console.log("eirianX[" + i + "]:" + eirianX[i] + " == nowCursorX[" + i + "]:"+ nowCursorX + "]");
            // エイリアンは破壊されるので無効状態になる
            eirianEnabledFlg[i] = 0;
            newMessage("座標：X[" + nowCursorX + "] Y[" + nowCursorY + "]のエイリアンを破壊しました。");
            return 1; // 破壊
        }
    }   
	return 0; // 破壊しなかった
	// todo:敵を破壊した音が必要
}

// ------------------------------------------------------------
// キーボードを押したときに実行される関数
// ------------------------------------------------------------
function KeyDownFunc(e){

	// ------------------------------------------------------------
	// 入力情報を取得
	// ------------------------------------------------------------
	// キーコード
	var key_code = e.keyCode;
	// Shiftキーの押下状態
	var shift_key = e.shiftKey;
	// Ctrlキーの押下状態
	var ctrl_key = e.ctrlKey;
	// Altキーの押下状態
	var alt_key = e.altKey;

	// ------------------------------------------------------------
	// 出力テスト
	// ------------------------------------------------------------
        console.log("code:" + key_code);
        pressedKey = key_code;

      CursorDraw();
      CommandInput();
}

function CommandInput()
{
	// キーボードよりsもしくはSが入力された場合、敵のステータス情報をコンソールに出力する。
	if (pressedKey == 83 || pressedKey == 115) {
		console.log("MAX_EIRIAN_NUM[" + MAX_EIRIAN_NUM + "]");
		for (var i=0; i< MAX_EIRIAN_NUM; i++) {
			console.log("EIRIAN[" + i + "] X:" + eirianX[i] + " Y:" + eirianY[i] + " TYPE:" + eirianType[i] + " eirianEnabledFlg:" + eirianEnabledFlg[i]);
		}	
	}
}

function CursorDraw()
{
    // 移動前のカーソルを消す
    ctx.beginPath();
    ctx.fillStyle="rgb(255,255,255)";
    ctx.fillRect(nowCursorX*50+2,nowCursorY*50+2,47,47);
    ctx.closePath();
    ctx.stroke();

	if (pressedKey == 98 || pressedKey == 40) 
	{ 
            nowCursorY = nowCursorY + 1;
    }
	if (pressedKey == 104 || pressedKey == 38) 
	{ 
             nowCursorY = nowCursorY - 1;
    }
	if (pressedKey == 100 || pressedKey == 37) 
	{ 
             nowCursorX = nowCursorX - 1;
    }
	if (pressedKey == 102 || pressedKey == 39) 
	{ 
             nowCursorX = nowCursorX + 1;
    }
    pressedKey = 0;
    console.log(nowCursorX.toString(10));
    console.log(nowCursorY.toString(10));
    ctx.beginPath();
    ctx.fillStyle="rgb(32,32,32)";
    if (cursorStatus == 0) {
//    	alert(1);
    }
    ctx.fillStyle="rgb(32,32,255)";
    ctx.fillRect(nowCursorX*50+2,nowCursorY*50+2,47,47);
    ctx.closePath();
    ctx.stroke();
}
function clearUnitsAll(){
	// カーソルの選択状態が「未選択」でなければユニットの再描画は行わない。
	// TODO:毎回全部の自軍ユニットを書き直すと重くなるので、必要なものだけを書き直すように設計をしたい。
	if (cursorStatus == 0) {
	    for(var i=0;i<NUM;i++) {
	        ctx.beginPath();
	        ctx.fillStyle="rgb(155,255,255)";
	        ctx.fillRect((unitX[i]-1)*50+2, (unitY[i]-1)*50+2,47,47);
	        ctx.closePath();
	        ctx.stroke();
	    }
	}
}

/**
 * 自軍のユニットを全て再描画する 
 *
 */
function setUnitsAll(){
	// TODO:毎回全部の自軍ユニットを書き直すと重くなるので、必要なものだけを書き直すように設計をしたい。
    for(var i=0;i<NUM;i++) {
        var img = new Image();
        if(unitType[i] == 0){
            img.src="UNIT_LV01.gif";
        } else if(unitType[i] == 1){
            img.src="UNIT_LV02.gif";
        } else if(unitType[i] == 2){
            img.src="UNIT_LV03.gif";
        } else if(unitType[i] == 3){
            img.src="UNIT_LV02.gif";
        } else if(unitType[i] == 4){
            img.src="TUNK_SENSYA_LV01.gif";
        } else if(unitType[i] == 5){
            img.src="TUNK_SENSYA_LV02.gif";
        } else if(unitType[i] == 6){
            img.src="TUNK_SENSYA_LV03.gif";
        } else if(unitType[i] == 7){
            img.src="TUNK_ROCKET_LV01.gif";
        } else if(unitType[i] == 8){
            img.src="TUNK_ROCKET_LV02.gif";
        } else if(unitType[i] == 9){
            img.src="TUNK_ROCKET_LV03.gif";
        } else if(unitType[i] == 10){
            img.src="FIGHTER_LV01.gif";
        } else if(unitType[i] == 11){
            img.src="FIGHTER_LV02.gif";
        } else if(unitType[i] == 12){
            img.src="FIGHTER_LV03.gif";
        }
        if ((cursorStatus == 0) || ((cursorStatus == 1) && (selectedUnitNo != i)) ) {
        	// カーソルが選択状態では無い場合、もしくは選択状態ではあるが掴んだユニットでは無い場合描画
            ctx.drawImage(img,(unitX[i]-1)*50+2,(unitY[i]-1)*50+2,47,47);
        }
    }
}

/**
 * 新しいエイリアンを追加する。
 *
 * TODO: エイリアン同士は排他制御に成功しているが、ユニットのあるマスにエイリアンが出力できてしまう。
 *
 */
function createNewEirian() {
    var check_counter = 0; // 全てのエイリアン有効無効フラグが無効(0)になっている場合をチェック
    var counter = lastCreateEirian;
    var outerWhileCond = true;
    while(outerWhileCond){
        if (counter > MAX_EIRIAN_NUM) {
            counter = 0;
        }
        // エイリアン有効無効フラグが無効(0)の場合は空き領域
        if (eirianEnabledFlg[counter] == 0) {
            // データの検査結果が有効ならエイリアン追加するループを抜ける
            outerWhileCond = false;
            eirianX[counter] = Math.floor((Math.random() * 10.0)) + 1;
            eirianY[counter] = Math.floor((Math.random() * 10.0)) + 1;
//          eirianType[counter] = Math.floor((Math.random() * 12.0)) + 1;

            for(var i = 0; i <= MAX_EIRIAN_NUM; i++){
                if(counter != i) {
                    // 既に他のエイリアンがその場所を埋めている場合はループを抜けて、違う場所を取得
                    if((eirianX[counter] == eirianX[i]) && (eirianY[counter] == eirianY[i])) {
                        i = MAX_EIRIAN_NUM;
                        outerWhileCond = true; // 検査結果がＮＧなので再びエイリアンを追加するループを回す
                    } 
                }
            }
            // 検査結果がＯＫの場合はエイリアンを有効(1)にする。
            if (!outerWhileCond) {
                // エイリアンは有効状態
                eirianEnabledFlg[counter] = 1;
            }
        } else {
            // エイリアン有効無効フラグが有効(1)の場合は使用中の領域
            counter++; // 次の領域が使えるか？
            check_counter++; // ループ回数も加算
        }
        if (check_counter >= MAX_EIRIAN_NUM) {
            var outerWhileCond = false; // 全てのエイリアンは無効
        }
    }
}
function clearEirian() {
    for(var i=0;i<=MAX_EIRIAN_NUM;i++) {
        ctx.beginPath();
        ctx.fillStyle="rgb(32,32,32)";
        ctx.fillRect((eirianX[i]-1)*50+2,(eirianY[i]-1)*50+2,47,47);
        ctx.closePath();
        ctx.stroke();
    }    
}
function setEirian() {
    var img = new Image();
//    img.src="EIRIAN_LV01.gif";
    img.src="EIRIAN_LV01.gif";

    for(var i=0;i<=MAX_EIRIAN_NUM;i++) {
        // エイリアン有効無効フラグが無効(1)の場合は利用中（描画が必要）
        if (eirianEnabledFlg[i] == 1) {
            ctx.drawImage(img,(eirianX[i]-1)*50+2,(eirianY[i]-1)*50+2,47,47);
        }
    }    
}

function drawBackGroundImage() {
    var img = new Image();
    img.src="./background-image-wood01.jpg";

    for(var i=0;i<=TOPX_SIZE;i++) {
    	for(var j=0;j<=TOPY_SIZE;j++){
    		ctx.drawImage(img,i*50+2,j*50+2);
    	}
    }
}
 

    </script>

</head>
<body onLoad="init()" scroll="no"
	style="overflow: hidden; position: fixed; background-color: #909090; height: 650px;">
	<table style="background-image: url('./pattern_148.gif');">
		<tr>
			<td>
				<div>
					<canvas id="main_canvas" height="500" width="500"></canvas>
				</div>
			</td>
			<td>
				<div style="background-image: url('./pattern_128.gif');">
					<canvas id="side_canvas" height="500" width="150"></canvas>
				</div>
			</td>
		</tr>
		<tr>
			<td>
				<div>
					<canvas id="message_window" height="150" width="500"></canvas>
				</div>
			</td>
			<td style="font-size: 6pt; background-color: #FFFFFF"><a
				href="http://www.squidfingers.com/patterns/">http://www.squidfingers.com/patterns/</a><br>
				<a href="http://photo.v-colors.com/" target="_blank" title="PHOTO STOCKER -高解像度の無料写真素材-へのリンク"><img src="http://photo.v-colors.com/images/bnPhoto200x50.jpg" alt="PHOTO STOCKER -高解像度の無料写真素材-" /></a>
			</td>
		</tr>
	</table>
</body>
</html>



